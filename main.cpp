#include "minhash.h"

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cout << "missing list filename" << endl;
        return 1;
    }
    string list_name = argv[1];
    
    int k = 31;
    hash<string> myhash;
    int s = 200;

    if (argc == 2) {
        make_similarity_matrix(list_name, k, myhash, s);
        return 0;
    } else if (argc == 3) {
        ofstream temp;
        temp.open(argv[2]);
        make_similarity_matrix(list_name, k, myhash, s, temp);
        temp.close();
        return 0;
    }
    cout << "number of arguments incorrect" << endl;
    return 1;

    // testing for large length strings

    // vector<string> strings = {"AAACTGGTCAACTCGGGTAAAGCTGCTCAGGGTCGAGGTTCATTACTCCAAAGTAATTGCTGGCTCAGCGGGTTCTACCAAAAGAACACGCATTCGGGACCGTCACTAACTGGAACGCGTTTATAAAATACTATACCTTCGCCGGATTGTTTCTTTGATATGGCATTCCGTAACGTATCACGTACAGCGTATAGGACTGGACAGACCATCTAGCAACGCGCTAAAGTCAAGCGCGGAACCGCACTCAGCGTTCAAAACCGTCCTTACAACGGTGGGCGAACACATTCAGGTCCGGTTGAGTTTGCTTTGATCCAGCTCTGAATTAGTAGCCTTGTAGGGTTGTAATGTGTAGTATAACTTTAATACTGGGCGCCCTGTTACGAGAGGACCAGTCCACATGGTGGTCCCCCCAGTCCATTCGCCACACTAATGGGTGTGCAGCCGTCATTGGTTTGGGAAACTCCAGCGTAACTCTGGCGCTTGTGCGGTACAAGAGGTCCCTCAGTGGCACGTTTTTAGTCTTTCACTTGGGTCTGTCAACGGACTGAGTATCCTCCGGAATCGAATATTTCACCGTTGTCAAGTTTTGAACCTCGAGCGGGAAAATGATCAATGTGTAACCTAACTTGGCTTCAGGGATTGCGAGGCACATTCTTATTTGTCCGGTAAGAGACACAGCGAGAAGGGGTCAGGACGGATCGCCGTGACTATCAAAAGTATCAAGGTAACCTGCCTCTTAGTCATCAACCCGGACCCTGAGTTAGGTTCCACTCCCATGGCAAGGGATGAGGATCTCCAAACTGAGTCTCCATACTTGTTCTACCAACCACTGTGACGGTAGGGACACACGTTGCGTCTATCGTCCGAGGCCACGCGGGCTGAGATGCTACATCGCTCGTTAGCCTCATCTCGTTCTTGCAGGGCCAGGCACGTTACCAGTAGTGCTCTAGGATGCATTCCCGCTCAAAAGTACAACGACTACCGGCATATTATGGAGACC"
    // , "AAACTGGTCAACTCGGGTAAAGCTGCTCAGGGTCGAGGTTCATTACTCCAAAGTAATTGCTGGCTCAGCGGGTTCTACCAAAAGAACACGCATTCGGGACCGTCACTAACTGGAACGCGTTTATAAAATACTATACCTTCGCCGGATTGTTTCTTTGATATGGCATTCCGTAACGTATCACGTACAGCGTATAGGACTGGACAGACCATCTAGCAACGCGCTAAAGTCAAGCGCGGAACCGCACTCAGCGTTCAAAACCGTCCTTACAACGGTGGGCGAACACATTCAGGTCCGGTTGAGTTTGCTTTGATCCAGCTCTGAATTAGTAGCCTTGTAGGGTTGTAATGTGTAGTATAACTTTAATACTGGGCGCCCTGTTACGAGAGGACCAGTCCACATGGTGGTCCCCCCAGTCCATTCGCCACACTAATGGGTGTGCAGCCGTCATTGGTTTGGGAAACTCCAGCGTAACTCTGGCGCTTGTGCGGTACAAGAGGTCCCTCAGTGGCACGTTTTTAGTCTTTCACTTGGGTCTGTCAACGGACTGAGTATCCTCCGGAATCGAATATTTCACCGTTGTCAAGTTTTGAACCTCGAGCGGGAAAATGATCAATGTGTAACCTAACTTGGCTTCAGGGATTGCGAGGCACATTCTTATTTGTCCGGTAAGAGACACAGCGAGAAGGGGTCAGGACGGATCGCCGTGACTATCAAAAGTATCAAGGTAACCTGCCTCTTAGTCATCAACCCGGACCCTGAGTTAGGTTCCACTCCCATGGCAAGGGATGAGGATCTCCAAAGACTTATAATTGCTAGACCGATGTCCGGGAAAAAGGTTGGTCTCGTTCGAGGATTCACCCACCGTATCTGGTTTTAACGAACCTATGGTTGAGAAGACAGTTAGGGGCTATTCGGGCCAGCTCTACTTTTTCGGTGTCTGTTACTGACTCCTACTGGGTAGCGGTCTTTCGTATTGCCAAGGGCCATCCACCGATGACGG"
    // , "AAACTGGTCAACTCGGGTAAAGCTGCTCAGGGTCGAGGTTCATTACTCCAAAGTAATTGCTGGCTCAGCGGGTTCTACCAAAAGAACCGGATATGGGTGTCGTTTTGTCCGTTCAGGGCGCGGTAATTGAGGATGTGGCCACAGTATGAGATTGTATGCGATTGTAGTGAAGTCGTGTGGAACACTGTAATGCTACTGACAGGGCGTGCTGCGATCGACTTTACGGACTATGGCGAACGGTTGATGCAATGCCAGATGGCGTTAACCATTCGATGACCTGCGCCGTGAGAGCGCTTTTGTTTATTCAGTATTAGCCGTACGGAGGCATTAGCATTGGTGTTGCCATGTCGTCCGTGTTCGTTATGATGGGCGCCCTGTTACGAGAGGACCAGTCCACATGGTGGTCCCCCCAGTCCATTCGCCACACTAATGGGTGTGCAGCCGTCATTGGTTTGGGAAACACATACGTAGTCCGCGTGTTGGAATGATGATTCCGGGATAGGCTGTGGAGCATTCTGCAAGGGTTAGGTAGGTCGTATGTTGTGGTAGCGCATGGCTTCTCATTGTTGTAGACCTGAGGTGACGAAGAGTGTGGAACCGCAGGAGTCGGAAGGGATTACATTTATGCCTGCGTGTGACGGAATCGAATTCTGTAGTACCGTATGCCAGGGTGGTGAGCCTCTCGTAGGACGTTTTAGGTTTGATAGTATGTACATCAGTAGTTAGAGGTCTGGCAGGGAATTCGCGCTGTCAAGTGGGACGGTATCAACGCAGTTCTCATTGTATTCATTTGCATGCAAGTCCGGTAGGACTGCCGGCTGGACCAACGATGTGTCGGGAAGGAGTTTGCAATAGGTAGTCCGTAGTCCTTCACTGGAAGCCGCGGGTGACAGTGCTCTGTTGATCCGATATTCATGGACTATTTTACGTGGAGACGGGGCCTTAGTATCCTACTGGGTAGCGGTCTTTCGTATTGCCAAGGGCCATCCACCGATGACGG"
    // }; 

    // unordered_set<string> A_sketch = bottom_k_sketch_fromfile("A.txt", k, myhash, s);
    // unordered_set<string> B_sketch =  bottom_k_sketch_fromfile("B.txt", k, myhash, s);
    // std::cout << estimate_jaccard(A_sketch, B_sketch, myhash, s) << std::endl;

    // vector<unordered_set<string>> kmer_sets;
    // int n = strings.size();
    // vector<vector<double>> similarity(n, vector<double>(n, 0));
    // for (int i = 0 ; i < n; i++) {
    //     kmer_sets.push_back(make_kmer_set(strings[i], k));
    //     for (int j = 0; j <= i; j++) {
    //         if (i == j) {
    //             similarity[i][j] = 1;
    //         } else {
    //             double intersect_size = 0;
    //             for (const auto& kmer : kmer_sets[i]) {
    //                 if (kmer_sets[j].find(kmer) != kmer_sets[j].end()) {
    //                     intersect_size++;
    //                 }
    //             }
    //             double temp =  intersect_size/(kmer_sets[i].size() + kmer_sets[j].size() - intersect_size);
    //             similarity[i][j] = temp;
    //             similarity[j][i] = temp;
    //         }
    //     }
    // }
    // cout << "actual" << endl;
    // for (int i = 0; i < n; i++) {
    //     for (int j = 0; j < n; j++) {
    //         cout << similarity[i][j] << "\t";
    //     }
    //     cout << endl;
    // }
    // double intersect_size = 0;
    // for (const auto& kmer : A) {
    //     if (B.find(kmer) != B.end()) {
    //         intersect_size++;
    //     }
    // }
    // std::cout << "actual:" << intersect_size/(A.size() + B.size() - intersect_size) << std::endl;
}